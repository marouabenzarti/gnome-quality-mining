% This file was created with JabRef 2.4.2.
% Encoding: UTF8

@INPROCEEDINGS{Romanski2003,
  author = {George Romanski},
  title = {Requirements, Configuration Management and Traceability for Safety
	Critical Software},
  booktitle = {IEEE International Conference on Requirements Engineering},
  year = {2003},
  pages = {304},
  address = {Monterey Bay, CA, USA},
  month = {September},
  publisher = {IEEE Computer Society},
  note = {Keynote},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  comment = {DBLP entry for conf/re/Romanski03},
  crossref = {DBLP:conf/re/2003},
  groups = {public},
  interhash = {ac54633ef4d240112a15c2c47a05375d},
  intrahash = {2928f316ceff4cfcba33afbca147ee71},
  isbn = {0-7695-1980-6},
  keywords = {traceabilty, evolution, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://csdl.computer.org/comp/proceedings/re/2003/1980/00/19800304.pdf}
}

@INPROCEEDINGS{Anton2001,
  author = {A. I. Anton and C. Potts},
  title = {Functional paleontology: system evolution as the user sees it},
  booktitle = {International Conference on Software Engineering},
  year = {2001},
  pages = {421--430},
  address = {Toronto, Canada},
  abstract = {It has long been accepted that requirements analysis should precede
	architectural design and implementation, but in software evolution
	and reverse engineering this concern with black-box analysis of function
	has necessarily been de-emphasized in favor of code-based analysis
	and designer-oriented interpretation. We redress this balance by
	describing 'functional paleontology': an approach to analyzing the
	evolution of user-visible features or services independent of architecture
	and design intent. We classify the benefits and burdens of interpersonal
	communication services into core and peripheral categories and investigate
	the telephony services available to domestic subscribers over a fifty-year
	period. We report that services were introduced in discrete bursts,
	each of which emphasized different benefits and burdens. We discuss
	the general patterns of functional evolution that this "fossil record"
	illustrates and conclude by discussing their implications for forward
	engineering of software products.},
  groups = {public},
  interhash = {945667fcd74968378f4f71c24275f2d2},
  intrahash = {9508f65be58d3723174c302e8fc7434e},
  keywords = {2106, evolution, requirements, litmap},
  owner = {neilernst},
  privnote = {- define functional morphology: the shape of benefits and burdens
	of a system.- a system is modeled as a set of services, which offer
	potential to fulfil goals. An appropriate service supports goals
	for a stakeholder.- benefit realized is hindered by burdens, mostly
	NFRs- core/modulating services (meta-level); autonomous/reactive
	benefits; amplified benefits- map the morphology of a phone system
	over time to determine whether evolution is gradual or punctuated.
	Latter seems most prevalent (but can we readily apply biological
	notions here?)- what does a service epoch suggest?- clearly there
	are influences on this evolution, incl privatization, tech improvements.
	Authors suggest this is ignorable since it's context-sensitive and
	irrelevant to larger purpose- suggestions: design for core functionality
	and core users; customizations not very important; downstream reactive
	actions by users should be considered;- stakeholders affect one another;-
	service scenarios may be temporally disjointed unlike use cases-
	compare with actitivy theory of Nardi, services are tools, something
	recruited for a purpose},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=919115}
}

@MISC{atkin2006,
  author = {Albert Atkin},
  title = {Peirce's Theory of Signs},
  month = {October},
  year = {2006},
  groups = {public},
  intrahash = {5b23aec06e99c6c2c5e274cabd08aa3c},
  keywords = {semiotics},
  organization = {Stanford Encyclopedia of Philosophy},
  owner = {nernst},
  timestamp = {2009.02.16},
  url = {http://plato.stanford.edu/entries/peirce-semiotics/}
}

@INPROCEEDINGS{Baysal2007,
  author = {Olga Baysal and Andrew J. Malton},
  title = {Correlating Social Interactions to Release History during Software
	Evolution},
  booktitle = {Workshop on Mining Software Repositories at ICSE},
  year = {2007},
  pages = {7-7},
  address = {Minneapolis, Minnesota},
  month = {May },
  abstract = {In this paper, we propose a method to reason about the nature of software
	changes by mining and correlating discussion archives. We employ
	an information retrieval approach to find correlation between source
	code change history and history of social interactions surrounding
	these changes. We apply our correlation method on two software systems,
	LSEdit and Apache Ant. The results of these exploratory case studies
	demonstrate the evidence of similarity between the content of free-form
	text emails among developers and the actual modifications in the
	code. We identify a set of correlation patterns between discussion
	and changed code vocabularies and discover that some releases referred
	to as minor should instead fall under the major category. These patterns
	can be used to give estimations about the type of a change and time
	needed to implement it.},
  doi = {10.1109/MSR.2007.4},
  groups = {public},
  interhash = {b31d3cb2f4d53206ef47b4d73ff46773},
  intrahash = {ba68639c69406f14e7911b46397d4b8f},
  isbn = {0-7695-2950-X},
  keywords = {social, evolution, software, mining},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?isnumber=4228635&arnumber=4228644&count=35&index=8}
}

@INPROCEEDINGS{Blyth1993,
  author = {A.J.C. Blyth and J. Chudge and J.E. Dobson and M.R. Strens},
  title = {A framework for modelling evolving requirements},
  booktitle = {Intl Conf. Computer Software and Applications Conference (COMPSAC
	93)},
  year = {1993},
  pages = {83-89},
  address = {Phoenix, AZ},
  abstract = {The most crucial aspect of software engineering is the gatheringof
	requirements. Increasing the amount of time and improving the qualityof
	effort expended at this stage will lead to fewer and more manageableproblems
	later on in the development life-cycle. The purpose of thispaper
	is to highlight one of the most crucial problems that afflict userorganizations
	when engaging in IT systems: the problem that therequirements for
	the system may change and evolve during theconstruction of the system.
	What we propose in this paper is a frameworkin which evolving and
	emerging requirements can be dealt with in aniterative manner within
	a method constructed upon a user-centered designphilosophy. This
	paper is a presentation of recent developments made inthe ORDIT project
	which was reported on last year},
  doi = {10.1109/CMPSAC.1993.404219},
  groups = {public},
  interhash = {d77a1806db3e278079dd114c133c70b5},
  intrahash = {552dd9bd764332a11e66202e36d7954e},
  isbn = {0-8186-4440-0},
  keywords = {evolution, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=404219}
}

@ARTICLE{Boegh2008,
  author = {Jørgen Bøegh},
  title = {A New Standard for Quality Requirements},
  journal = {IEEE Software},
  year = {2008},
  volume = {Mar/Apr},
  pages = {57--63},
  abstract = {A new standard on software quality requirements, ISO/IEC 25030, takes
	a systems perspective and suggests specifying requirements as measures
	and associated target values.},
  groups = {public},
  intrahash = {4d4d8357a56b451a41700aff1a4858e3},
  keywords = {quality, taxonomy},
  owner = {neilrnst},
  timestamp = {2009.02.22}
}

@ARTICLE{Chapin2001,
  author = {Ned Chapin and Joanne E. Hale and Juan Fernandez-Ramil and Wui-Gee
	Tan},
  title = {Types of software evolution and software maintenance},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice},
  year = {2001},
  volume = {13},
  pages = {3--30},
  number = {1},
  abstract = {The past two decades have seen increasing sophistication in software
	work. Now and in the future, the work of both practitioners and researchers
	would be helped by a more objective and finer granularity recognition
	of types of software evolution and software maintenance activities
	as actually done. To these ends, this paper proposes a clarifying
	redefinition of the types of software evolution and software maintenance.
	The paper bases the proposed classification not on people's intentions
	but upon objective evidence of maintainers' activities ascertainable
	from observation of activities and artifacts, and/or a before and
	after comparison of the software documentation. The classification
	includes taking into account in a semi-hierarchical manner evidence
	of the change or lack thereof in: (1) the software, (2) the documentation,
	(3) the properties of the software, and (4) the customer-experienced
	functionality. A comparison is made with other classifications and
	typologies. The paper provides a classified list of maintenance activities
	and a condensed decision tree as a summary guide to the proposed
	evidence-based classification of the types of software evolution
	and software maintenance.},
  comment = {Not previously uploaded},
  doi = {10.1002/smr.220},
  groups = {public},
  interhash = {94e157b14308f24cf3b3a146887f4a49},
  intrahash = {90e3c09f10e3b5ec06f3d79658cce415},
  keywords = {evolution, software, taxonomy},
  misc_id = {606026},
  owner = {neilernst},
  priority = {3},
  publisher = {John Wiley \& Sons, Ltd.},
  timestamp = {2009-02-16 22:00:18},
  url = {http://dx.doi.org/10.1002/smr.220}
}

@INPROCEEDINGS{Dagenais2007,
  author = {Barthélémy Dagenais and Silvia Breu and Frédéric Weigand Warr and
	Martin P. Robillard},
  title = {Inferring structural patterns for concern traceability in evolving
	software},
  booktitle = {International Conference on Automated software engineering},
  year = {2007},
  pages = {254--263},
  address = {Atlanta, Georgia, USA},
  publisher = {ACM},
  abstract = {As part of the evolution of software systems, effort is ofteninvested
	to discover in what parts of the source code afeature (or other concern)
	is implemented. Unfortunately,knowledge about a concern’s implementation
	can becomeinvalid as the system evolves. We propose to mitigate thisproblem
	by automatically inferring structural patterns amongthe elements
	identified as relevant to a concern’s implementation.We then document
	the inferred patterns as rules thatcan be checked as the source code
	evolves. Checking whetherstructural patterns hold across different
	versions of a systemenables the automatic identification of new elements
	relatedto a documented concern. We implemented our techniquefor Java
	in an Eclipse plug-in called ISIS4J and applied itto a number of
	concerns. With a case study spanning 34versions of the development
	history of an open-source system,we show how our approach supports
	the tracking ofa concern’s implementation through modifications such
	asextensions and refactorings.},
  comment = {Inferring structural patterns for concern traceability in evolving
	software},
  groups = {public},
  interhash = {b5a8f9b5e62d0c215f1fe14eab64094d},
  intrahash = {4541ee285cf8e56bde258aebb9cd7311},
  keywords = {concern, evolution, empirical},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://doi.acm.org/10.1145/1321631.1321669}
}

@ARTICLE{Desai2008,
  author = {Nirmit Desai and Amit K. Chopra and Munindar P. Singh},
  title = {Amoeba: A Methodology for Requirements Modeling and Evolution of
	Cross-Organizational Business Processes},
  journal = {Transactions on Software Engineering and Methodology},
  year = {2008},
  note = {submitted},
  abstract = {Business service engagements involve processes that extend across
	two or more autonomous organizations. Because of regulatory and competitive
	reasons, requirements for business processesoften evolve in subtle
	ways. The changes may concern the business transactions supported
	by abusiness process, the organizational structure of parties participating
	in the process, or the con-textual policies that apply to the process.
	Current business process modeling approaches handlesuch changes in
	an ad hoc manner, and lack a principled means of determining what
	needs tobe changed and where. Cross-organizational settings exacerbate
	the shortcomings of traditionalapproaches because changes in one
	organization can affect the workings of another.This paper describes
	Amoeba, a methodology for business processes that is based on businessprotocols.
	Protocols capture the business meaning of interactions among autonomous
	parties viacommitments. Amoeba proposes guidelines for (1) specifying
	cross-organizational processes usingbusiness protocols, and (2) handling
	evolution of requirements via a novel application of protocolcomposition.
	This paper evaluates Amoeba using enhancements of a real-life business
	scenario ofauto-insurance claim processing.},
  groups = {public},
  interhash = {ceade3b95befeff4d290c65adae54532},
  intrahash = {87c64c8fe1149284fb127a33092697b6},
  keywords = {evolution, requirements, business},
  owner = {neilernst},
  privnote = {- "the difficulty of accommodating changing business needs in current
	IT systems" -- interesting observation- "Existing approaches either
	ignore interaction or address it purely in low level terms that correspond
	more to implementations (such as by specifying the legal message
	exchange sequences between services) than business-level specification
	of interaction. Consequently, existing approaches limit flexibility
	in implementations, andthey also do not offer a notion of compliance
	suitable for business interaction." -- similar to what I have been
	arguing about software evolution research.- treatment of interaction
	at the level of businessmeaning, not merely at the level of messaging,
	as is common today (meaning = semantics?) (no, meaning implies intention
	-purpose driven)- commitments seem similar to dependencies (obligations
	or must-do intentional elements)- "composition is central to the
	ability to adapt process models according to evolving requirements"-
	"three classes of business requirements" - transactional, structural,
	contextual. One might argue problem frames do as good a job... -
	"unlike commitments, goals cannot be manipulated via delegation or
	assignment." referring to Tropos. Really? you can delegate the things
	that achieve goals.. but how would I delegate a goal? It's mine.
	A commitment is just a task dependency.},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www4.ncsu.edu/~nvdesai/tosem07.pdf}
}

@ARTICLE{Dig2006,
  author = {Danny Dig and Ralph Johnson},
  title = {How do APIs evolve? A story of refactoring},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice},
  year = {2006},
  volume = {18},
  pages = {83-107},
  number = {2},
  abstract = {Frameworks and libraries change their APIs. Migrating an application
	to the new API is tedious and disrupts the development process. Although
	some tools and ideas have been proposed to solve the evolution of
	APIs, most updates are done manually. To better understand the requirements
	for migration tools, we studied the API changes of four frameworks
	and one library. We discovered that the changes that break existing
	applications are not random, but tend to fall into particular categories.
	Over 80% of these changes are refactorings. This suggests that refactoring-based
	migration tools should be used to update applications.},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  groups = {public},
  interhash = {5dab2dbec55d79fcd7286cb84150757f},
  intrahash = {5ba58e7e6f0f83d14191a7bbc2b72a30},
  keywords = {framework, evolution, should-read},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://dx.doi.org/10.1002/smr.328}
}

@INPROCEEDINGS{Fabbrini2007,
  author = {F. Fabbrini and M. Fusani and S. Gnesi and G. Lami},
  title = {Controlling Requirements Evolution: a Formal Concept Analysis-Based
	Approach},
  booktitle = {International Conference on Software Engineering Advances},
  year = {2007},
  pages = {68},
  publisher = {IEEE Computer Society},
  abstract = {Requirements evolve during the software development process. Requirements
	specification evolution determines changes both in terms of level
	of details and style of representation and it brings the requirements
	from the initial statement of the customer needs towards more detailed
	documents able to drive the software design, construction and verification.
	Controlling the evolution of requirements, usually written in natural
	language, is very important for the success of the whole software
	project because every step in the evolutionary path of requirements
	can introduce undesired changes or lacks of information. This paper
	describes an approach based on the Formal Concepts Analysis that
	allows a systematic and precise verification of the consistency among
	different stages of natural language requirements evolution.},
  doi = {http://dx.doi.org/10.1109/ICSEA.2007.24},
  groups = {public},
  interhash = {a706c2f889247c0c17e9ec27d05c4f55},
  intrahash = {044a9c8af12b0b7b225c242f14df4159},
  isbn = {0-7695-2937-2},
  keywords = {evolution, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4299948}
}

@INPROCEEDINGS{Gall1997,
  author = {Harald Gall and Mehdi Jazayeri and René Klösch and Georg Trausmuth},
  title = {Software Evolution Observations Based on Product Release History},
  booktitle = {International Conference on Software Maintenance},
  year = {1997},
  pages = {160--166},
  address = {Bari, Italy},
  month = {October 1--3},
  abstract = {Large software systems evolve slowly but constantly. In this paper
	we examine the structure of several releases of a telecommunication
	switching system (TSS) based on information stored in a database
	of product releases. We tracked the historical evolution of the TSS
	structure and related the adaptations made (e.g. addition of new
	features, etc.) to the structure of the system. Such a systematic
	examination can uncover potential shortcomings in the structure of
	the system and identify modules or subsystems that should be subject
	to restructuring or reengineering. Further, we have identified additional
	information that would be useful for such investigations but is currently
	lacking in the database.},
  comment = {dblp},
  date = {2002-10-18},
  ee = {http://computer.org/proceedings/icsm/8013/80130160abs.htm},
  groups = {public},
  interhash = {4bb50dfde6983010278cbb682f1f90d2},
  intrahash = {05623e9f6c14f6be31741d66393871ed},
  isbn = {0-8186-8013-X},
  keywords = {product, evolution, software, history},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=624242}
}

@INPROCEEDINGS{Godfrey2000,
  author = {Michael W. Godfrey and Qiang Tu},
  title = {Evolution in Open Source Software: A Case Study},
  booktitle = {International Conference on Software Maintenance},
  year = {2000},
  pages = {131--142},
  address = {San Jose, California},
  month = {October},
  publisher = {IEEE Computer Society},
  abstract = {Most studies of software evolution have been performed on systems
	developed within a single company using traditional management techniques.
	With the widespread availability of several large software systems
	that have been developed using an â€œopen sourceâ€ development approach,
	we now have a chance to examine these systems in detail, and see
	if their evolutionary narratives are significantly different from
	commercially developed systems. The paper summarizes our preliminary
	investigations into the evolution of the best known open source system:
	the Linux operating system kernel. Because Linux is large (over two
	million lines of code in the most recent version) and because its
	development model is not as tightly planned and managed as most industrial
	software processes, we had expected to find that Linux was growing
	more slowly as it got bigger and more complex. Instead, we have found
	that Linux has been growing at a super-linear rate for several years.
	The authors explore the evolution of the Linux kernel both at the
	system level and within the major subsystems, and they discuss why
	they think Linux continues to exhibit such strong growth},
  doi = {10.1109/ICSM.2000.883030},
  groups = {public},
  interhash = {1b0e12e65d24279a962782bda3e40479},
  intrahash = {290390167f71426da0a1de4998f4e57c},
  keywords = {open-source, evolution, litmap},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://portal.acm.org/citation.cfm?id=853411}
}

@INPROCEEDINGS{Gross2001,
  author = {Daniel Gross and Eric Yu},
  title = {Evolving System Architecture to Meet Changing Business Goals: an
	Agent and Goal-Oriented Approach},
  booktitle = {ICSE-2001 Workshop: From Software Requirements to Architectures (STRAW
	2001)},
  year = {2001},
  pages = {13--21},
  address = {Toronto, Canada},
  month = {May},
  abstract = {Today's requirements engineering approaches focus onnotation and techniques
	for modeling the intendedfunctionality and qualities of a software
	system. Littleattention has been given to systematically understandingand
	modeling the relationships between business goals andsystem qualities,
	and how these goals are met duringarchitectural design. In particular,
	modeling mustencompass changes to business goals over time and theireffects
	upon a system's architecture. This paper reports ona case study,
	performed at a telecommunication company,that illustrates the decision-making
	process regardingarchitectural changes introduced into an existing
	switchingsystem product. A notation including goals, strategicagents
	and intentional dependency relationships is used tosupport the architectural
	modeling and reasoning.},
  comment = {Evolving System Architecture to Meet Changing Business Goals: an Agent
	and Goal-Oriented Approach},
  groups = {public},
  interhash = {d6e6ea9977395035d155fc6466843e5e},
  intrahash = {c9a90702643fc3fb745bc6abd79436e3},
  keywords = {agent, goal, evolution, business},
  owner = {neilernst},
  privnote = {- mainly focused on supporting change during design, not afterwards-
	poor support for some claims e.g. design rationale is rarely used;
	- process is much harder to study than product- designers 'establish
	and refine architecture iteratively'? says who?},
  timestamp = {2009-02-16 22:00:18},
  url = {http://citeseer.ist.psu.edu/453529.html}
}

@ARTICLE{Girba2006,
  author = {Tudor Gîrba and Stéphane Ducasse},
  title = {Modeling history to analyze software evolution},
  journal = {Journal of Software Maintenance and Evolution: Research and Practice},
  year = {2006},
  volume = {18},
  pages = {207-236},
  number = {3},
  abstract = {The histories of software systems hold useful information when reasoning
	about the systems at hand or when reasoning about general laws of
	software evolution. Over the past 30 years, research has been increasingly
	spent on understanding software evolution. However, the approaches
	developed so far do not rely on an explicit meta-model and, thus,
	they make it difficult to reuse or compare their results. We argue
	that there is a need for an explicit meta-model for software evolution
	analysis. We present a survey of the evolution analyses and deduce
	a set of requirements that an evolution meta-model should have. We
	define Hismo, a meta-model in which history is modeled as an explicit
	entity. Hismo adds a time layer on top of structural information,
	and provides a common infrastructure for expressing and combining
	evolution analyses and structural analyses. We validate the usefulness
	of our meta-model by presenting how different analyses are expressed
	on it.},
  comment = {Presents a meta-model of software evolution, little focus on requirements},
  date = {2007-01-11},
  ee = {http://dx.doi.org/10.1002/smr.325},
  groups = {public},
  interhash = {6aad9a34935d8a29f9203159d0bc513b},
  intrahash = {737aeaee273faae15b9029dcfd0ea790},
  keywords = {modeling, evolution, software, visualization},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://dx.doi.org/10.1002/smr.325}
}

@INPROCEEDINGS{Herraiz2008,
  author = {Israel Herraiz and Jesus M. Gonzalez-Barahona and Gregorio Robles},
  title = {Determinism and evolution},
  booktitle = {International working conference on Mining software repositories},
  year = {2008},
  pages = {1--10},
  address = {Leipzig, Germany},
  publisher = {ACM},
  abstract = {It has been proposed that software evolution follows a Self-Organized
	Criticality (SOC) dynamics. This fact is supported by the presence
	of long range correlations in the time series of the number of changes
	made to the source code over time. Those long range correlations
	imply that the current state of the project was determined time ago.
	In other words, the evolution of the software project is governed
	by a sort of determinism. But this idea seems to contradict intuition.
	To explore this apparent contradiction, we have performed an empirical
	study on a sample of 3, 821 libre (free, open source) software projects,
	finding that their evolution projects is short range correlated.
	This suggests that the dynamics of software evolution may not be
	SOC, and therefore that the past of a project does not determine
	its future except for relatively short periods of time, at least
	for libre software.},
  comment = {Determinism and evolution},
  groups = {public},
  interhash = {a995a67ea6d2cc84fe307071edd765a1},
  intrahash = {08a245d999ab0ae9a2b80266fe84b319},
  isbn = {978-1-60558-024-1},
  keywords = {evolution, software},
  location = {Leipzig, Germany},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://doi.acm.org/10.1145/1370750.1370752}
}

@INPROCEEDINGS{Hindle2007,
  author = {Abram Hindle and Michael W. Godfrey and Richard C. Holt},
  title = {Release Pattern Discovery via Partitioning: Methodology and Case
	Study},
  booktitle = {International Workshop on Mining Software Repositories at ICSE},
  year = {2007},
  pages = {19--27},
  address = {Minneapolis, MN},
  abstract = {The development of Open Source systems produces a variety of software
	artifacts such as source code, version control records, bug reports,
	and email discussions. Since the development is distributed across
	different tool environments and developer practices, any analysis
	of project behavior must be inferred from whatever common artifacts
	happen to be available. In this paper, we propose an approach to
	characterizing a project's behavior around the time of major and
	minor releases; we do this by partitioning the observed activities,
	such as artifact check-ins, around the dates of major and minor releases,
	and then look for recognizable patterns. We validate this approach
	by means of a case study on the MySQL database system; in this case
	study, we found patterns which suggested MySQL was behaving consistently
	within itself. These patterns included testing and documenting that
	took place more before a release than after and that the rate of
	source code changes dipped around release time.},
  doi = {10.1109/MSR.2007.28},
  groups = {public},
  interhash = {8b83c0589b25a23fe54e9b3b850e9527},
  intrahash = {68afcae946b0849f0bd1869bf3cc7113},
  isbn = {0-7695-2950-X},
  keywords = {release, evolution, visualization},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4228656}
}

@INPROCEEDINGS{Holmes2007,
  author = {Reid Holmes and Robert J. Walker},
  title = {Supporting the Investigation and Planning of Pragmatic Reuse Tasks},
  booktitle = {International Conference on Software Engineering},
  year = {2007},
  pages = {447-457},
  address = {Minneapolis, USA},
  month = {May},
  abstract = {Software reuse has long been promoted as a means to increase developer
	productivity; however, reusing source code is difficult in practice
	and tends to be performed in an ad hoc manner. This is problematic
	because poor decisions can be made either to attempt an unwise, overly
	complex reuse task, or to avoid a reuse task that would have saved
	time and effort. This paper describes a lightweight tool that supports
	the investigation and planning of pragmatic reuse tasks. The tool
	helps developers to identify the dependencies from the source code
	they wish to reuse, and to decide how to deal with those dependencies.
	Questions about pragmatic reuse are evaluated through a survey of
	industrial developers. The tool is evaluated through the planning
	and execution of reuse tasks by industrial developers.},
  comment = {Welcome to IEEE Xplore 2.0: Supporting the Investigation and Planning
	of Pragmatic Reuse Tasks},
  doi = {10.1109/ICSE.2007.83},
  groups = {public},
  interhash = {4ac9534f3f21eab533e09e99fc45be9b},
  intrahash = {f4c7b1536fbfe7614404c568e6d93977},
  issn = {0270-5257},
  keywords = {reuse, empirical, msr},
  owner = {neilernst},
  privnote = {},
  timestamp = {2009-03-01 17:46:00},
  url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=4222606}
}

@INPROCEEDINGS{Jiang2008,
  author = {Hsin-Yi Jiang and Tien Nguyen and Ing-Xiang Chen},
  title = {Incremental Latent Semantic Indexing for Effective, Automatic Traceability
	Link Evolution Management},
  booktitle = {Intl Conf. on Software Engineering},
  year = {2008},
  address = {Leipzig, Germany},
  month = {May},
  abstract = {Maintaining traceability links among software artifacts isparticularly
	important for many software engineering tasks.Even though automatic
	traceability link recovery tools aresuccessful in identifying the
	semantic connections amongsoftware artifacts produced during software
	development, noexisting traceability link management approach can
	e®ec-tively and automatically deal with software evolution. Wepropose
	a technique to automatically manage traceabilitylink evolution and
	update the links in evolving software. Ournovel technique, called
	incremental Latent Semantic Index-ing (iLSI), allows the fast and
	low-cost LSI computation forthe update of traceability links by analyzing
	the changes tosoftware artifacts and by re-using the results from
	previousLSI computation before the changes. We present our iLSItechnique,
	and describe a complete automatic traceabilitylink evolution management
	tool, TLEM, that is capable ofinteractively and quickly updating
	traceability links in thepresence of evolving software artifacts.
	We report on ourempirical evaluation with various experimental studies
	toassess the performance and usefulness of our approach.},
  groups = {public},
  interhash = {75b0cced5cca56ab791096f88319afd5},
  intrahash = {c46d19a954b854e23d9ce9bd859fb8e2},
  keywords = {traceability, Evolution},
  owner = {neilernst},
  privnote = {Use incremental updates to an LSI result to preserve traceability
	links. A minor improvement.},
  timestamp = {2009-02-16 22:00:18}
}

@ARTICLE{King1984,
  author = {John Leslie King and Kenneth L. Kraemer},
  title = {Evolution and organizational information systems: an assessment of
	Nolan's stage model },
  year = {1984},
  volume = {27 },
  pages = {466-475 },
  month = {May},
  abstract = {Richard Nolan's stage model is the best known and most widely cited
	model of computing evolution in organizations. The model's development
	over a decade demonstrates its own evolution from a simple theory,
	based on the factoring of change states indicated by changes in computing
	budgets, to an elaborate account of the characteristics of six stages
	of computing growth. An analysis of the model's logical and empirical
	structure reveals a number of problems in its formulation that help
	to account for the fact that its principal tenets have not been independently
	validated. The model is shown to be an ?evolutionistic? theory within
	the theories of evolution in the social sciences, focusing on assumed
	directions of growth and an implied end state toward which growth
	proceeds, and suffering from problems inherent in such theories.
	Further research based on an ?evolutionary? view of computing growth
	is suggested as a means of improving theories of computing in organizations.},
  comment = {zotero},
  groups = {public},
  interhash = {45731282faf9f004b28d50a036548f25},
  intrahash = {6e39f1dd1112b852b356b6a43ca57103},
  keywords = {of, computing,, evolution, model, stages, computing,nolan's},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18}
}

@TECHREPORT{Kruchten2003,
  author = {Philippe Kruchten},
  title = {Using the RUP to evolve a legacy system},
  institution = {IBM},
  year = {2003},
  type = {Rational Technical Report},
  month = {November},
  abstract = {Think you can't use RUP with your existing system? Think again. Some
	people claim that the Rational Unified Process™ (RUP) is only useful
	for "green field" development, that is, the development of a brand
	new system, from the ground up, in an empty green field. They contend
	that it cannot be used for further development or evolution of a
	"legacy" system. I strongly disagree: I know that large portions
	of the RUP can be used to evolve an existing system. Actually, about
	80 percent of the sites where the RUP is used today include some
	form of legacy. },
  comment = {Using the RUP to evolve a legacy system},
  groups = {public},
  interhash = {6ed870452cb9ce6945664cf3387c8884},
  intrahash = {5a095432399ede602bb5ad81d969c296},
  keywords = {agile, evolution, RUP, legacy},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.ibm.com/developerworks/rational/library/389.html}
}

@INPROCEEDINGS{Lam1998,
  author = {W. Lam and M. Loomes},
  title = {Requirements Evolution in the Midst of Environmental Change: A Managed
	Approach},
  booktitle = {Euromicro Conference on Software Maintenance and Reengineering},
  year = {1998},
  pages = {121-127},
  address = {Florence, Italy},
  month = {March},
  publisher = {IEEE},
  note = {Requirements evolve, not only during system development but also
	after a system has been installed. The aim of the work on the EVE
	(EVolution Engineering) project is to develop practi-cal methods
	for dealing with requirements evolution. This pa-per presents the
	early output from our work-the EVE frame-work for requirements evolution.
	The EVE framework is com-prised of two components: a meta-model and
	an associated process model. The EVE meta-model captures a set of
	model-ling concepts in requirements evolution, including change,
	impact, risk and viewpoint. The EVE process model provides technologists
	with a framework for handling the emergence of new or changing requirements
	during the lifetime of a system. The paper illustrates the EVE framework
	on a simple example, and highlights the importance of social and
	environmental re-sponsibility in requirements evolution.},
  abstract = {Requirements evolve, not only during system development but also after
	a system has been installed. The aim of the work on the EVE (EVolution
	Engineering) project is to develop practi-cal methods for dealing
	with requirements evolution. This pa-per presents the early output
	from our work-the EVE frame-work for requirements evolution. The
	EVE framework is com-prised of two components: a meta-model and an
	associated process model. The EVE meta-model captures a set of model-ling
	concepts in requirements evolution, including change, impact, risk
	and viewpoint. The EVE process model provides technologists with
	a framework for handling the emergence of new or changing requirements
	during the lifetime of a system. The paper illustrates the EVE framework
	on a simple example, and highlights the importance of social and
	environmental re-sponsibility in requirements evolution.},
  comment = {zotero},
  groups = {public},
  interhash = {04820b074f4883e1264213611398d284},
  intrahash = {01f1ebd9c0df9c02f2851cf1ebcd27d5},
  keywords = {Requirements, evolution, model, change},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/search/wrapper.jsp?arnumber=665774}
}

@TECHREPORT{LaMantia2007,
  author = {Matthew J. LaMantia and Yuanfang Cai and Alan D. MacCormack and John
	Rusnak},
  title = {Evolution Analysis of Large-Scale Software Systems Using Design Structure
	Matrices and Design Rule Theory},
  institution = {Harvard Business School},
  year = {2007},
  type = {Technical report},
  number = {07-081},
  month = {June},
  abstract = {Designers often seek modular architectures to better accommodate expected
	changes and to enable parallel development. However, we lack a formal
	theory and model of modularity and software evolution, which can
	be used for description, prediction, and prescription. According
	to Baldwin and Clark's theory, modular architectures add value to
	system designs by creating options to improve the system by substituting
	or experimenting on individual modules. In this paper, we evaluate
	their theory by looking at the design evolution of two software product
	platforms through the modeling lens of design structure matrices
	(DSMs) and design rule theory. Our analysis shows that DSM models
	and options theory can explain how real-world modularization activities
	in one case allowed for different rates of evolution in different
	software modules and in another case conferred distinct strategic
	advantages on a firm (by permitting substitution of an at-risk software
	module without substantial change to the rest of the system). The
	experiment supports our hypothesis that these formal models and theory
	can account for important aspects of software design evolution in
	large-scale systems.},
  groups = {public},
  interhash = {4062597cc1c811c241f3071f0a45d3ce},
  intrahash = {c6d8f187fea91e257f4f18c1800cfe3b},
  keywords = {evolution, systems, business},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://hbswk.hbs.edu/item/5699.html}
}

@BOOK{Lehman1985,
  title = {Program Evolution: Processes of Software Change},
  publisher = {Academic Press},
  year = {1985},
  author = {Meir M. Lehman and L. A. Belady},
  series = {APIC Studies In Data Processing},
  address = {London},
  groups = {public},
  interhash = {2879d9878b5f74552b578db038e96357},
  intrahash = {1bea83bb8b4d63d4cac2a9dfc33516e7},
  isbn = {0-124-42440-6},
  keywords = {seminal, evolution, software},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18}
}

@INBOOK{Lehman2006,
  pages = {7--40},
  title = {Software Evolution},
  publisher = {Wiley},
  year = {2006},
  author = {Meir M. Lehman and Juan F. Ramil},
  address = {UK},
  comment = {zotero},
  groups = {public},
  interhash = {286a80b305e7b28f78751f7c08e04326},
  intrahash = {bcd4f09492f7c96289ab9fc83f5e0745},
  journal = {Software Evolution and Feedback: Theory and Practice},
  keywords = {evolution},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18}
}

@INPROCEEDINGS{Lormans2007,
  author = {Marco Lormans},
  title = {Monitoring Requirements Evolution using Views},
  booktitle = {European Conference on Software Maintenance and Reengineering (CSMR'07)},
  year = {2007},
  pages = {349--352},
  address = {Amsterdam},
  month = {March},
  abstract = {This paper describes a research project concentrating on improving
	requirements management. We started this research by identifying
	the problems companies face with respect to requirements engineering
	in general, and requirements management in particular. We learned
	that monitoring requirements satisfaction is a major problem in practice.
	Requirements change continuously, making the traceability of requirements
	hard and the monitoring of requirements unreliable. As a solution,
	we develope a framework (Requirements Engineering System (RES)) that
	structures the process of requirements evolution, and a methodology
	that improves the traceability and monitoring of requirements. This
	methodology covers most of the processes defined in RES. We will
	implement the methodology in a tool, called ReqAnalyst. It uses Latent
	Semantic Index (LSI), an Information Retrieval technique, to recover
	the traceability links between the requirements and other work products.
	This traceability information will be used to generate ?requirements
	views? that help monitoring the requirements. We will apply the methodology
	in several case studies.},
  comment = {zotero},
  groups = {public},
  interhash = {0677135101169bc1805f6fe0cde934e7},
  intrahash = {2036bda00ae3f8b8f96e932b6a21ac8c},
  keywords = {evolution, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://doi.ieeecomputersociety.org/10.1109/CSMR.2007.36 }
}

@INPROCEEDINGS{Lungu2007,
  author = {Mircea Lungu and Michele Lanza},
  title = {Exploring Inter-Module Relationships in Evolving Software Systems},
  booktitle = {European Conference on Software Maintenance and Reengineering (CSMR)},
  year = {2007},
  pages = {91--100},
  address = {Amsterdam},
  month = {March},
  publisher = {IEEE Computer Society},
  abstract = {Many of the existing approaches to reverse architecting–the reverse
	engineering of the architecture of softwaresystems– are based on
	software exploration tools which provideinteractive ways of exploring
	the system. These toolsstart with high-level views of the system
	and refine themwith drill-down techniques applied on the high-level
	entitiessuch as modules and packages, leaving aside valuableinformation
	contained in the dependencies between them.In this article we argue
	that the visualization ofinter-module relations bears great potential
	for supportingthe understanding of large evolving software systems.We
	present two concrete examples of such visualizations.The first, The
	Semantic Dependency Matrix is atechnique for displaying details about
	a dependency betweentwo modules which groups together classes withsimilar
	behavior. The second, The Edge Evolution Filmstrippresents the evolution
	of an inter-module relationthrough multiple versions of the system.
	Based on our experiencewith the Edge Evolution Film Strip, we proposea
	pattern language for inter-module relationships. We exemplifyboth
	the visualizations and the pattern languagewith examples from two
	large open source software systems.},
  day = {21-23},
  groups = {public},
  interhash = {594e2a47cbf8d737888b15dbebde450e},
  intrahash = {6e769692ef8dd900ac1931e5fbef7653},
  keywords = {evolution, should-read, software, visualization},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.inf.unisi.ch/phd/lungu/research/publications/resources/Lungu07-RelationshipEvolutionPatterns.pdf}
}

@INPROCEEDINGS{Marcus2004,
  author = {A. Marcus and A. Sergeyev and V. Rajlich and J.I. Maletic},
  title = {An information retrieval approach to concept location in source code},
  booktitle = {Working Conference on Reverse Engineering},
  year = {2004},
  pages = { 214-223},
  month = {Nov},
  abstract = { Concept location identifies parts of a software system that implement
	a specific concept that originates from the problem or the solution
	domain. Concept location is a very common software engineering activity
	that directly supports software maintenance and evolution tasks such
	as incremental change and reverse engineering. This work addresses
	the problem of concept location using an advanced information retrieval
	method, Latent Semantic Indexing (LSI). LSI is used to map concepts
	expressed in natural language by the programmer to the relevant parts
	of the source code. Results of a case study on NCSA Mosaic are presented
	and compared with previously published results of other static methods
	for concept location.},
  comment = {},
  doi = ,
  groups = {public},
  interhash = {1711becee2dfb7b2faed2b37806cdb45},
  intrahash = {e98e4ba97c56fbb00b285bc46cd19432},
  issn = {1095-1350  },
  keywords = {concept, software, msr, nlp},
  owner = {neilernst},
  privnote = {},
  timestamp = {2009-03-01 17:46:00},
  url = {http://dx.doi.org/10.1109/WCRE.2004.10}
}

@INPROCEEDINGS{Mylopoulos2007,
  author = {John Mylopoulos and Neil Ernst},
  title = {Dynamically evolving requirements},
  booktitle = {Design Requirements Workshop},
  year = {2007},
  address = {Case Western University, Cleveland, OH},
  month = {June},
  publisher = {NSF},
  note = {position paper},
  groups = {public},
  interhash = {608bf4071af9b20409a87b645c192887},
  intrahash = {3d2e9b359d07b65799b09854240afe07},
  keywords = {evolution, requirements, personal},
  owner = {neilernst},
  privnote = {NSF sponsored project on design in large-scale systems},
  timestamp = {2009-02-16 22:00:18},
  url = {http://weatherhead.case.edu/requirements/reqs-attend.html}
}

@INBOOK{Nanda2006,
  pages = {161--180},
  title = {A Case Study of Software Requirements Changes Due to External Factors},
  year = {2006},
  author = {Vic Nanda and Nazim H. Madhavji},
  comment = {zotero},
  groups = {public},
  interhash = {52802c2bbb5ee05aa2144ba75612bba6},
  intrahash = {a5b54795e9952bfe94b942084c51caee},
  journal = {Software Evolution and Feedback: Theory and Practice},
  keywords = {evolution, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18}
}

@INPROCEEDINGS{Ovaska2004,
  author = {Päivi Ovaska},
  title = {MEASURING REQUIREMENT EVOLUTION: A Case Study in the E-commerce Domain},
  booktitle = {International Conference on Enterprise Information Systems},
  year = {2004},
  address = {Porto, Portugal},
  month = {April 14--17},
  note = {Poster?},
  abstract = {Although requirement evolution is a widely recognized phenomenon,
	there are only a few approaches formeasuring it. These existing approaches
	are based on the assumption that all the requirements exist and canbe
	seen in the requirement elicitation and analysis phases. They do
	not include provisions for the emergenceduring systems development
	of new requirements, which cannot be anticipated in the requirement
	elicitationand analysis phase. This paper shows how the concept of
	requirements creep is adopted for themeasurement of emergent requirement
	evolution. We use a case study in the E-commerce domain toillustrate
	the use of this measure in the prediction of systems development.
	The findings of this studysuggest that requirement evolution can
	be measured in a practical software project, and the findingsdemonstrate
	the strong influence of requirements creep on the systems development
	effort. The findings ofour study encourage us to undertake further
	studies involving other organizations and projects.},
  groups = {public},
  interhash = {a786af61d093d7e0861fd878f2e4fed5},
  intrahash = {e904a7828eff368474d8a8a8dcb5ecbe},
  keywords = {evolution, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www-lih.univ-lehavre.fr/Intranet/proceedings/ICEIS2004/ICEIS%202004/Area%203%20-%20Information%20Systems%20Analysis%20and%20Specification/Posters/C3_476_Ovaska.pdf}
}

@ARTICLE{Robbes2007,
  author = {Romain Robbes and Michele Lanza},
  title = {A Change-based Approach to Software Evolution},
  journal = {Electronic Notes in Theoretical Computer Science},
  year = {2007},
  volume = {166},
  pages = {93--109},
  month = {January},
  abstract = {Software evolution research is limited by the amount of information
	available to researchers: Current version control tools do not store
	all the information generated by developers. They do not record every
	intermediate version of the system issued, but only snapshots taken
	when a developer commits source code into the repository. Additionally,
	most software evolution analysis tools are not a part of the day-to-day
	programming activities, because analysis tools are resource intensive
	and not integrated in development environments. We propose to model
	development information as change operations that we retrieve directly
	from the programming environment the developers are using, while
	they are effecting changes to the system. This accurate and incremental
	information opens new ways for both developers and researchers to
	explore and evolve complex systems.},
  booktitle = {Proceedings of the ERCIM Working Group on Software Evolution (2006)},
  groups = {public},
  interhash = {31ff929e5ac7b01a343a6b0fd47bafe1},
  intrahash = {408b9ad3a7bd57abc7bdffc60bf9e708},
  keywords = {Evolution, Systems, IDEs, Software, Versioning},
  owner = {neilernst},
  privnote = {This paper suggests finer-grained versioning is needed with more semantics
	for the change operations. Would be good in reference to the Molhado
	work.},
  publisher = {Science Direct},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.sciencedirect.com/science/article/B75H1-4MK6WP6-7/2/d14d94b3eca2f801b34dd3c24d4557b6}
}

@INPROCEEDINGS{Robillard2008,
  author = {Martin Robillard and Barthélémy Dagenais},
  title = {Retrieving Task-Related Clusters from Change History},
  booktitle = {Working Conference on Reverse Engineering},
  year = {2008},
  address = {Antwerp, Belgium},
  month = {October},
  abstract = {During software maintenance tasks, developers oftenspend an important
	amount of effort investigating sourcecode. This effort can be reduced
	if tools are available tohelp developers navigate the source code
	effectively. Forthis purpose, we propose to search the change history
	ofa software system to identify clusters of program elementsrelated
	to a task. We evaluated the feasibility of this ideawith an extensive
	historical analysis of change data. Ourstudy evaluated to what extent
	change sets approximatingtasks could have benefited from knowledge
	about clustersof past changes. A study of 3 500 change sets for seven
	differentsystems and covering a cumulative time span of closeto 12
	years of development shows that less than 12% of thechanges could
	have benefited from change clusters. We reporton our observations
	on the factors that influence howwe can use change clusters to guide
	program navigation.},
  groups = {public},
  interhash = {714c52f78d9483c02db229c88c48e861},
  intrahash = {cc3b4a017b1bae947cc0d339369062d9},
  keywords = {evolution, empirical, change},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.cs.mcgill.ca/~martin/papers/wcre2008.pdf}
}

@INPROCEEDINGS{Robles2005,
  author = {G. Robles and J.J. Amor and J.M. Gonzalez-Barahona and I. Herraiz},
  title = {Evolution and growth in large libre software projects},
  booktitle = {International Workshop on Principles of Software Evolution},
  year = {2005},
  pages = { 165-174},
  month = {Sept.},
  abstract = {Software evolution research has recently focused on new development
	paradigms, studying whether laws found in more classic development
	environments also apply. Previous works have pointed out that at
	least some laws seem not to be valid for these new environments and
	even Lehman has labeled those (up to the moment few) cases as anomalies
	and has suggested that further research is needed to clarify this
	issue. In this line, we consider in this paper a large set of libre
	(free, open source) software systems featuring a large community
	of users and developers. In particular, we analyze a number of projects
	found in literature up to now, including the Linux kernel. For comparison,
	we include other libre software kernels from the BSD family, and
	for completeness we consider a wider range of libre software applications.
	In the case of Linux and the other operating system kernels we have
	studied growth patterns also at the subsystem level. We have observed
	in the studied sample that super-linearity occurs only exceptionally,
	that many of the systems follow a linear growth pattern and that
	smooth growth is not that common. These results differ from the ones
	found generally in classical software evolution studies. Other behaviors
	and patterns give also a hint that development in the libre software
	world could follow different laws than those known, at least in some
	cases.},
  comment = {Welcome to IEEE Xplore 2.0: Evolution and growth in large libre software
	projects},
  groups = {public},
  interhash = {d741176101174073a5472a34f66fa256},
  intrahash = {a5bb0485652b35f41d762d8d00827c8e},
  issn = {1550-4077},
  keywords = {linux, oss, empirical, msr},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:00},
  url = {http://dx.doi.org/10.1109/IWPSE.2005.17}
}

@ARTICLE{Roshandel2004,
  author = {Roshanak Roshandel and Andr\&\#233; Van Der Hoek and Marija Mikic-Rakic
	and Nenad Medvidovic},
  title = {Mae -- a system model and environment for managing architectural
	evolution},
  journal = {ACM Trans. Softw. Eng. Methodol.},
  year = {2004},
  volume = {13},
  pages = {240--276},
  number = {2},
  month = {April},
  abstract = {As with any other artifact produced as part of the software life cycle,
	software architectures evolve and this evolution must be managed.
	One approach to doing so would be to apply any of a host of existing
	configuration management systems, which have long been used successfully
	at the level of source code. Unfortunately, such an approach leads
	to many problems that prevent effective management of architectural
	evolution. To overcome these problems, we have developed an alternative
	approach centered on the use of an integrated architectural and configuration
	management system model. Because the system model combines architectural
	and configuration management concepts in a single representation,
	it has the distinct benefit that all architectural changes can be
	precisely captured and clearly related to each other---both at the
	fine-grained level of individual architectural elements and at the
	coarse-grained level of architectural configurations. To support
	the use of the system model, we have developed Mae, an architectural
	evolution environment through which users can specify architectures
	in a traditional manner, manage the evolution of the architectures
	using a check-out/check-in mechanism that tracks all changes, select
	a specific architectural configuration, and analyze the consistency
	of a selected configuration. We demonstrate the benefits of our approach
	by showing how the system model and its accompanying environment
	were used in the context of several representative projects.},
  address = {New York, NY, USA},
  comment = {Not previously uploaded},
  doi = {10.1145/1018210.1018213},
  groups = {public},
  interhash = {47cac9006bf687b1845a5c4d120e4e53},
  intrahash = {c66dd2afcf02647720479da71cdec4d9},
  keywords = {architecture, evolution, software},
  misc_id = {328045},
  owner = {neilernst},
  priority = {3},
  publisher = {ACM Press},
  timestamp = {2009-02-16 22:00:18},
  url = {http://dx.doi.org/10.1145/1018210.1018213}
}

@ARTICLE{Scacchi2002,
  author = {Walt Scacchi},
  title = {Understanding the requirements for developing open source softwaresystems},
  journal = {IET Software},
  year = {2002},
  volume = {149},
  pages = {24-39},
  number = {1},
  abstract = {Presents an initial set of findings from an empirical study ofsocial
	processes, technical system configurations, organisationalcontexts
	and interrelationships that give rise to open software. Thefocus
	is directed at understanding the requirements for open softwaredevelopment
	efforts, and how the development of these requirementsdiffers from
	those traditional to software engineering and requirementsengineering.
	Four open software development communities are described,examined
	and compared to help discover what these differences may be.Eight
	kinds of software informalisms are found to play a critical rolein
	the elicitation, analysis, specification, validation and managementof
	requirements for developing open software systems. Subsequently,understanding
	the roles these software informalisms take in a newformulation of
	the requirements development process for open sourcesoftware is the
	focus of the study. This focus enables the considerationof a reformulation
	of the requirements engineering process and itsassociated artefacts,
	or (in)formalisms, to better account for therequirements for developing
	open source software systems},
  comment = {Welcome to IEEE Xplore 2.0: Understanding the requirements for developing
	open source softwaresystems},
  doi = {10.1049/ip-sen:20020202},
  groups = {public},
  interhash = {37df32132d9b13231cab520ff7bd4830},
  intrahash = {888fa5f167be9bd60a39c47ee37d2cfd},
  issn = {1462-5970},
  keywords = {evolution, oss, requirements},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://ieeexplore.ieee.org/xpls/abs_all.jsp?arnumber=999088}
}

@ARTICLE{Scacchi2006,
  author = {Walt Scacchi and Joseph Feller and Brian Fitzgerald and Scott Hissam
	and Karim Lakhani},
  title = {Understanding Free/Open Source Software Development Processes},
  journal = {Software Process: Improvement and Practice},
  year = {2006},
  volume = {11},
  pages = {95 --105},
  number = {2},
  month = {March/April},
  abstract = {This article introduces a special issue of Software Process – Improvement
	and Practice focusing onprocesses found in free or open source software
	development (F/OSSD) projects. It seeks toprovide a background overview
	of research in this area through a review of selected empiricalstudies
	of F/OSSD processes. The results and findings from a survey of empirical
	studies ofF/OSSD give rise to an interesting variety of opportunities
	and challenges for understandingthese processes, which are identified
	along the way. Overall, what becomes clear is that studiesof F/OSSD
	processes reveal a more diverse set of different types of processes
	than have typicallybeen examined in conventional software development
	projects. The articles in this special issuefurther advance understanding
	of what processes characterize and shape F/OSSD},
  comment = {AO Evolution chapter short paper},
  groups = {public},
  interhash = {5aa7f1c02622c015bab7d46a156f05bf},
  intrahash = {098640d29eb4ad3256e0401b45936031},
  keywords = {evolution, could-read, oss},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.ics.uci.edu/~wscacchi/Papers/New/SPIP-FOSS-Intro-Dec2005.pdf}
}

@ARTICLE{Schopf2000,
  author = {J. William Schopf},
  title = {Solution to Darwin's dilemma: Discovery of the missing Precambrian
	record of life},
  journal = {Proceedings of the National Academy of Sciences},
  year = {2000},
  volume = {97},
  pages = {6947-6953},
  month = {June},
  comment = {zotero},
  groups = {public},
  interhash = {a67feb2cc24d7c0e180f7cf8b5512a0a},
  intrahash = {f8237008df9ceb211b9042edc1676ede},
  keywords = {evolution},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.pnas.org/cgi/content/abstract/97/13/6947}
}

@TECHREPORT{Simmonds2000,
  author = {Ian Simmonds and David Ing},
  title = {A Shearing Layers Approach to Information Systems Development },
  institution = {IBM Research},
  year = {2000},
  number = {RC 21694},
  address = {IBM Research},
  abstract = {In this paper we respond to the observation that systems are subjected
	to qualitatively different scales and rates of change, and should
	consequently be constructed to adapt in"shearing layers. "This observation
	applies equally to social systems such as business(or other)enterprises,
	and to the software systems that they use. Our response is multifaceted,
	concerned with three different objects of design: the design of two
	kinds of organization; the functional design of software applications
	to support those organizations; and the implementation of those applications
	as software. The two relevant kinds of organization are large information
	systems services organizations, and the organizations that use their
	services. When an organization is designed to respond to change it
	is called an adaptive enterprise. Software so designed is called
	adaptable software. Among these three forms of design, this paper
	focuses on the middle one. We propose constructs called"agents"and"conversations"as
	means for reasoning about the functional design of adaptable software.
	The bridge to organization design comes from determining which people
	should engage in what conversations to achieve what forms of learning.
	The bridge to software implementation comes from determining how
	to deploy each conversation within available middleware and other
	technologies. We do not wish to claim that shearing layers is a new
	phenomenon in information system development. Indeed, we present
	examples of practices consistent with this approach. Rather, we seek
	to name the phenomenon, present theory that embraces that phenomenon,
	and demonstrate how we are applying that theory within our ongoing
	work. As a result, this paper can be seen as a source not only of
	newly explicit requirements on software engineering, but also of
	some possible solutions},
  comment = {IBM Research | Technical Paper Search | A Shearing Layers Approach
	to Information Systems Development},
  groups = {public},
  interhash = {810311cacf9da2d91dfd2902dad3f5de},
  intrahash = {f3248745718139dcbdb47fd9ca740c60},
  keywords = {evolution, constraint, design},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://systemicbusiness.org/pubs/2000_IBM_RC21694_Simmonds_Ing_Shearing_Layers_Info_Sys_Dev.html}
}

@INPROCEEDINGS{Sneed2007,
  author = {Harry Sneed},
  title = {The Drawbacks of Model-Driven Software Evolution},
  booktitle = {Workshop on Model-Driven Software Evolution at CSMR},
  year = {2007},
  address = {Amsterdam},
  month = {March},
  abstract = {This short paper is an essay on the drawbacks of modeldriven software
	evolution which apply equally well tomodel driven software development.
	The idea ofautomatically generating code changes from a UMLtype model
	is equally enticing as that of automaticallygenerating whole components
	from such a model. Thedrawback is that there is then nothing to test
	against,since there is only one description of the system, themodel.
	This violates the principles of softwareverification and validation,
	according to whichcorrectness can only be demonstrated by comparingtwo
	independent descriptions of the same solution. Forthis reason, the
	author proposes another interpretationof model driven evolution,
	one in which therequirements model serves as a basis for propagatingchanges
	to both the code and the test, along twoindependent paths. The UML
	type system design couldthen be generated from the code and not [vice]
	versa},
  groups = {public},
  interhash = {207867f184bd6af02fa9059b0401ea37},
  intrahash = {0194bcfa92f21ac8ea1a6eae482d5cb2},
  keywords = {evolution, model, Software},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.sciences.univ-nantes.fr/MoDSE2007/p9.pdf}
}

@INPROCEEDINGS{Stojanovic2002,
  author = {L. Stojanovic and A. Maedche and B. Motik and N. Stojanovic},
  title = {User-driven Ontology Evolution Management},
  booktitle = {European Conference on Knowledge Engineering and Knowledge Management
	{EKAW}},
  year = {2002},
  pages = {285--301},
  address = {Madrid, Spain},
  month = {October},
  abstract = {With rising importance of knowledge interchange, many industrial and
	academic applications have adopted ontologies as their conceptual
	backbone. However, industrial and academic environments are very
	dynamic, thus inducing changes to application requirements. To fulfill
	these changes, often the underlying ontology must be evolved as well.
	As ontologies grow in size, the complexity of change management increases,
	thus requiring a well-structured ontology evolution process. In this
	paper we identify a possible six-phase evolution process and focus
	on providing the user with capabilities to control and customize
	it. We introduce the concept of an evolution strategy encapsulating
	policy for evolution with respect to user's requirements.},
  day = {1--4},
  groups = {public},
  interhash = {1e6e870727585954990a293a48f711fe},
  intrahash = {260c5eb551d3209926f453c5f27e6742},
  keywords = {ontology, evolution},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.springerlink.com/content/cgu1ltk11y3njtyn/}
}

@ARTICLE{Svahnberg2005,
  author = {Mikael Svahnberg and Jilles van Gurp and Jan Bosch},
  title = {A taxonomy of variability realization techniques.},
  journal = {Softw., Pract. Exper.},
  year = {2005},
  volume = {35},
  pages = {705-754},
  number = {8},
  comment = {dblp},
  groups = {public},
  interhash = {9689523f051453a947f7f1251935cffd},
  intrahash = {6ab9a79f3a20711a25425e2d55062964},
  keywords = {evolution, taxonomy},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://dx.doi.org/10.1002/spe.652}
}

@INPROCEEDINGS{Swanson1976,
  author = {Burton E. Swanson},
  title = {The dimensions of maintenance},
  booktitle = {Intl. Conf. on Software Engineering},
  year = {1976},
  pages = {492--497},
  address = {San Francisco, California},
  publisher = {IEEE Computer Society},
  abstract = {The area of software maintenance has been described by one author
	as an â€œiceberg.â€� (EDP Analyzer, 1972) Much goes on here that
	does not currently meet the eye. In part, this is the consequence
	of measurement difficulties. Practitioners and researchers can benefit
	from an understanding of the â€œdimensionalityâ€� of the maintenance
	problem. Some measures are suggested for coming to grips with this
	dimensionality, and problems of utilization associated with these
	measures are explored.},
  comment = {Not previously uploaded},
  groups = {public},
  interhash = {6476a2a5dee91abbba3889d81507c9af},
  intrahash = {6d469c2804bca47b02b559177c1925be},
  keywords = {seminal, maintenance, evolution, software},
  misc_id = {768959},
  owner = {neilernst},
  priority = {0},
  timestamp = {2009-02-16 22:00:18},
  url = {http://portal.acm.org/affiliated/citation.cfm?id=807723&dl=ACM&coll=ACM&CFID=15151515&CFTOKEN=6184618}
}

@ARTICLE{Wan-Kadir2004,
  author = {W. M. N. Wan-Kadir and Pericles Loucopoulos},
  title = {Relating evolving business rules to software design},
  journal = {Journal of Systems Architecture},
  year = {2004},
  volume = {50},
  pages = {367--382},
  number = {7},
  month = jul,
  note = {Adaptable System/Software Architectures},
  abstract = {In order to remain useful, it is important for software to evolve
	according to the changes in its business environment. Business rules,
	which can be used to represent both user requirements and conditions
	to which the system should conform, are considered as the most volatile
	part in today's software applications. Their changes bring high impact
	on both the business processes and the software itself. In this paper,
	we present an approach that considers business rules as an integral
	part of a software system and its evolution. The approach transcends
	the areas of requirements specification and software design. We develop
	the Business Rule Model to capture and specify business rules, and
	the Link Model to relate business rules to the metamodel level of
	software design elements. The aim is to improve requirements traceability
	in software design, as well as minimizing the efforts of software
	changes due to the changes of business rules. The approach is demonstrated
	using examples from an industrial application.},
  groups = {public},
  interhash = {1a432be9ff1028ed1cbf48e9c44d05ae},
  intrahash = {016a71c6014bd36e5d0c1e648350600f},
  keywords = {rules, evolution, Business, architecture/design, User, requirements,
	Software},
  owner = {neilernst},
  timestamp = {2009-02-16 22:00:18},
  url = {http://www.sciencedirect.com/science/article/B6V1F-4B3MV6W-3/2/d6210685d0d23b70e28c9c4ea48c3dcf}
}

@STANDARD{iso9126,
  title = {Software engineering -- Product quality -- Part 1: Quality model},
  organization = {International Standards Organization - JTC 1/SC 7},
  number = {ISO9126-1},
  revision = {90.60},
  year = {2001},
  doi = {JTC 1/SC 7},
  editor = {François Coallier}
}

@BOOK{Fellbaum1998,
  title = {WordNet: An Electronic Lexical Database},
  publisher = {MIT Press},
  year = {1998},
  editor = {Christiane Fellbaum},
  pages = {445},
  isbn = {978-0-262-06197-1},
  owner = {neilrnst},
  timestamp = {2009.03.01},
  url = {http://mitpress.mit.edu/catalog/item/default.asp?ttype=2&tid=8106}
}

@comment{jabref-meta: selector_journal:}

@comment{jabref-meta: selector_author:}

@comment{jabref-meta: selector_keywords:1406;2106;2228;Evolution;Goal;
Information;MAS;Model;OCL;Requirements;Software;Systems;Technology;UML
;abstraction;acquisition;action;adaptation;adoption;agent;agile;ai;alg
ebra;analysis;and;architecture;argumentation;aspects;automatic;autonom
ic;economics;elicitation;emergent;empirical;engineering;engineering,so
ftware;ethics;ethnography;evaluation;evolution;evolution,must-read,rel
ease;expert;feature;flow;folksonomy;forking;formal;formulation;frames;
framework;fuzzy;geography;gis;goal;goals;graph;grid;grounded;hci;hiera
rchy;history;hypermedia;i*;i-star;imported;inconsistency;inference;inf
ormation;inquiry;integration;interaction;interface;interfaces;protege;
protocol;prototyping;psychology;qualitative;quality;query;rapid;ration
ale;rdf;re-read;reasoning;reference;release;representation;requirement
s;research;retrieval;reverse;revision;risk;safety;scenario;schema;scr;
semantic;seminal;service;services;should-read;simulation;sketching;soa
p;social;society;software;source;specification;spiral;standard;statech
art;statecharts;structural;study;survey;system;systems;task;taxonomy;1
406;2106;2228;Evolution;Goal;Information;MAS;Model;OCL;Requirements;So
ftware;Systems;Technology;UML;abstraction;acquisition;action;adaptatio
n;adoption;agent;agile;ai;algebra;analysis;and;architecture;argumentat
ion;aspects;automatic;autonomic;economics;elicitation;emergent;empiric
al;engineering;engineering,software;ethics;ethnography;evaluation;evol
ution;evolution,must-read,release;expert;feature;flow;folksonomy;forki
ng;formal;formulation;frames;framework;fuzzy;geography;gis;goal;goals;
graph;grid;grounded;hci;hierarchy;history;hypermedia;i*;i-star;importe
d;inconsistency;inference;information;inquiry;integration;interaction;
interface;interfaces;programming;protege;protocol;prototyping;psycholo
gy;qualitative;quality;query;rapid;rationale;rdf;re-read;reasoning;ref
erence;release;representation;requirements;research;retrieval;reverse;
revision;risk;safety;scenario;schema;scr;semantic;seminal;service;serv
ices;should-read;simulation;sketching;soap;social;society;software;sou
rce;specification;spiral;standard;statechart;statecharts;structural;st
udy;survey;system;systems;}

@comment{jabref-meta: selector_publisher:}

